## this란?

다른 객체지향 언어의 this란? 클래스로 생성한 인스턴스 객체

JS 에서의 this

- JS에서 this는 어디서든 사용 OK
- JS에서 상황에 따라 this가 바라보는 대상 달라지는데 원리&이유를 잘 알지 못하면 힘들어짐 !!
- JS에서this 는 함수와 객체(메서드) 이 둘을 구분하는 유일한 기능.

## 학습목표

1. 상황별로 this가 어떻게 달라지는가
2. 왜 달라지는가
3. 예상 외 다른 대상을 바라보고 있을 경우 효과적인 원인 추적 방법을 알아보자

## 01. 상황에 따라 달라지는 this

기본적으로

- JS에서 this는 실행컨텍스트가 생성될 때 결정됨.
    - 함수 호출할 때 → 실행컨텍스트 생성 == **this는 함수호출할 때 결정된다.**
        - 어떤 방식으로 함수 호출하냐에 따라 → this 값이 달라진다 !!
    

이제 각종 상황에서의 this를 알아보자. 

### 1) 전역 공간에서의 this

- 전역 공간 안에 this → 전역 객체 가리킴
    
    *why?*
    
    > JS에서 this는 실행컨텍스트가 생성될 때 결정됨
    → 전역 객체가 전역 컨텍스트 생성 → this가 전역 객체를 가리키는 것으로 결정 !
    > 
    
- 브라우저 환경에서 전역객체 : window
- Node.js 환경에서 전역객체 : global
    - JS 런타임 환경에 따라 전역객체 달라짐
    

### 2) 메서드로서 호출할 때 그 메서드 내부에서의 this

함수 실행 방법은 여러가지가 있다. 

1) 함수로서 호출 하는 경우

2) 메서드로서 호출하는 겅우

함수 & 메서드 의 공통점 : 프로그래밍 언어에서 미리 정의한 동작을 수행하는 코드 뭉치다. 

함수 와 메서드의 유일한 차이는 **독립성에 있다.** 

- 함수 : 그 자체로 독립적인 기능 수행 .
- 메서드 : 자신을 호출한 대상 객체에 관한 동작을 수행.
    
     ⇒  JS는 상황별로 this 키워드에 다른 값을 부여하게 함으로써 이 특징을 구현함.
    

여기서 퀴즈 

> 메서드는 객체의 프로퍼티에 할당된 함수이다. ( O / X )
> 

반은 맞고 반은 틀리다. 

어떤 함수를 객체의 프로퍼티로 할당하면 무조건 메서드 ! (X)

객체의 메서드로서 호출할 경우에만 메서드로 동작. 그렇지 않으면 함수로 동작 (O)

```jsx
// 변수func에 익명함수 할당.
var func = function (x) {
	console.log(this, x);
}

func(1) // 결과: window { ... } 1
// this로는 전역객체 window 출력됨

var obj = {
	method: func
}
obj.method(2); // 결과 : {method: f} 2
// 객체obj의 메소드를 출력했더니 this로 obj를 출력
```

객체 obj의 method 프로퍼티 할당 값,  변수func 의 할당값 모두 첫줄에서 선언한 함수를 참조함.

⇒ 원래의 익명함수는 그대로인데 , 
(1) 이를 변수에 담아 호출한 경우 (함수로서 호출)
(2) obj객체의 프로퍼티에 할당해서 호출한 경우 (메서드로서 호출)

두 경우 this가 달라진다.

그렇다면 ‘함수로서 호출’ 과 ‘메서드로서 호출’ 어떻게 구분할까?
⇒ 함수 앞에 점(.)이 있는지 여부만으로 간단하게 구분 가능.

예제 3-6 의 `func(1)` 는 앞에 점 없음 → 함수로서 호출됨.

예제 3-6 의 `obj.method(2)` 는 method 앞에 점이 있음 → 메서드로 호출됨. 

**메서드 내부에서의 this**

- this에는 호출한 주체에 대한 정보가 담긴다.
    - 어떤 함수를 메서드로서 호출하는 경우, 호출 주체 : 함수명(프로퍼티명) 앞의 객체
        - 점 표기법의 경우 → 마지막 점 앞에 명시된 객체가 곧 this.
        
        ```jsx
        var obj = {
        
        	method: function () {console.log(this)},
        
        	inner: {
        	methodB: function () {console.log(this)}
        	}
        
        }
        
        obj.methodA(); // 여기서 this는 obj (점표기법)
        
        obj[’methodA’]() // 여기서 this는 obj (대괄호표기법)
        
        ---
        
        obj.inner.methodB(); // 여기서 this는 obj.inner (점표기법)
        
        obj.inner.[’methodB’](); // 여기서 this는 obj.inner (대괄호표기법)
        ```
        

### 3) 함수로서 호출할 때 그 함수 내부에서의 this

**함수 내부에서의 this**

- 어떤 함수를 함수로서 호출할 경우 → this 지정되지 않는다.
    
    > this에는 호출한 주체에 대한 정보가 담긴다.
    > 
    - 함수로서 호출한다 == 호출주체 명시하지 않고 개발자가 코드에 직접 관여&실행하는 것.
        
        ⇒ 그렇기 때문에 함수로서 호출하면 호출 주체의 정보를 알 수 없다.  
        
        ⇒ 호출 주체 알 수없다 == this 지정X ⇒ this 지정 안되면 this는 전역객체 바라봄 (2장참고)
        
        *(더글라스 크락포드는 이를 명백한 설계상 오류라고 함)*
        
        ```jsx
        1. var obj1 = {
        
        2. 	outer: function () {
        	
        3.		console.log(this); // 결과1
        	
        4.		var innerFunc = function () {
        5.			console.log(this) // 결과2 결과3		
        6.		}
        	
        7.		innerFunc();
        	
        8.		var obj2 = {
        9.			innerMethod: innerFunc
        10.		};
        
        11.		obj2.innerMethod();
        	
        12.	 }
        
        13. };
        14. obj1.outer();
        ```
        
        결과1: obj1 , 결과2: 전역객체(window) , 결과3: obj2.innerMethod 
        
        - 해석
            - 1번줄
                - 객체 생성. 객체 내부에는 outer라는 프로퍼티가 있고 이 프로퍼티에 익명함수 연결됨. 이렇게 생성한 객체를 변수obj1 에 연결.
                14번줄: `obj1.outer()` 호출
            - 2줄:
                - obj1.outer함수의 실행컨텍스트 생성→호이스팅함 → 스코프체인 정보 수집 → this 바인딩.
                - outer() 함수 호출 할 때 앞에 점 있음 → 메서드로서 호출한 것. → 마지막 점 앞의 객체 obj1 에 바인딩
            - 3줄 :
                - 바인딩 된 obj1를 this로 출력
            - 4줄:
                - 호이스팅된 변수 innerFunc 는 outer스코프 내에서만 접근 가능한 지역변수.
                - 이 지역변수에 익명 함수 할당
            - 7줄:
                - innerFunc 호출
            - 4줄:
                - innerFunc 함수 실행 컨텍스트 생성 → 호이스팅 → 스코프 체인 수집 → this 바인딩
                - 7번줄을 보면 이 함수를 호출할 때 앞에 점이 없었음. ⇒ 즉, 함수로서 호출 → this 지정 X → 스코프체인 최상위 객체인 전역객체가 바인딩됨.
            - 5줄:
                - innerFunc 에 있는 콘솔로그 window가 출력.
            - 8줄:
                - 호이스팅된 변수 obj2 역시 outer 스코프 내에서만 접근 가능한 지역변수.
                - 여기에 다시 객체 할당 , 그 객체는 innerMethod 프로퍼티
                - innerMethod프로퍼티엔 먼저 정의했던 innerFunc 함수가 연결된다.
            - 11줄:
                - `obj2.innerMethod` 호출
                - obj2.innerMethod 함수의 실행 컨텍스트 생성 → innerMethod 앞에 점이 있었음 → 메서드로 호출 됨.⇒ this에 마지막 점 앞의 객체인 obj2가 바인딩됨
        
        i**nnerFunc를 함수로서 호출했냐, 메서드로서 호출했냐에 따라 innerFunc같은 함수임에도 바인딩되는this의 대상이 달라짐. (더글락스: 이게 설계상 오류다!)**
        
        ⇒ this바인딩에 관해서는 함수 실행 당시 주변 환경(메서드 내부인지, 함수내부인지 등) 중요하지 않음. 
        **오로지 , 호출하는 구문 앞에 점 또는 대괄호표기법 유무가 중요함**
        
        호출주체가 없을땐 주변 환경의 this를 그대로 상속받아 쓰거나 하면 좋겠지만.. 어쩔수없음.
        
        ES5까진 자체적으로 내부함수에 this를 상속하는 방법 없음.다만, 우회방법있음
        
        💥**메서드의 내부 함수에서의 this를 우회하는 방법**
        
        ```jsx
        var obj~~1~~ = {
         	outer: function () {
        	
        		console.log(this); // 결과1
        	
        		var innerFunc1 = function () {
        			console.log(this) // 결과2 결과3		
        		}
        	
        		innerFunc1();
        
        		var self = this;
        	
        		~~var obj2 = {
        			innerMethod: innerFunc
        		};
        
        		obj2.innerMethod();~~
        
        		var innerFunc2 = function () {
        			console.log(self)
        		}
        		innerFunc2();
        	 }
        
         };
        obj~~1~~.outer();
        ```
        
        변수 self에 this를 저장한 상태에서 호출한innerFunc2에서 self에는 객체 obj가 출력된다.
        
        ⇒ 상위스코프의 this를 저장해서 내부함수에서 활용하려는 수단.
        
        💥**this를 바인딩하지 않는 함수 (ES6의 화살표함수)**
        
        ES6부터 있는 화살표함수는 this를 바인딩하지 않는다. 
        
        화살표함수는 실행컨텍스트를 생성할 때 , this바인딩 과정 자체가 빠져있다.
        
        → 상위 스코프의 this를 그대로 활용할 수 있다.
        
        내부함수를 화살표 함수로 바꾸면 우회법 필요없이 상위스코프를 가져다 쓰게된다.
        

### 4) 콜백 함수 호출 시 그 함수 내부에서의 this

- 함수A의 제어권을 다른 함수B( 또는 메서드) 에게 넘겨주면 → 함수A를 콜백함수라고함.
- 콜백함수A는 함수B의 내부로직에 따라 실행됨.
- this 역시 함수 B내부 로직에 따라 값 결정됨.
- 콜백함수도 함수이기때문에 this가 전역객체를 참조. But, 제어권 받은 함수에서 콜백함수에 별도로 this대상을 지정할 경우 , 그걸로 바뀐다.

### 5) 생성자 함수 내부에서의 this

- 생성자 함수 : 공통성질을 지니는 객체들을 생성하는데 사용하는 함수.
- JS에서는 함수에 생성자로서의 역할을 함께 부여
- new 명령어랑 같이 함수를 호출하면 해당 함수가 생성자로서 동작한다.
- **어떤 함수가 생성자함수로서 호출되면 → 내부에서의 this는 곧 새로 만들 인스턴스 자신이 된다.**
    
    ```jsx
    var Cat = function (name, age){
    	this.bark = '야옹';
    	this.name = name;
    	this.age = age;
    };
    
    var choco = new Cat('초코', 7);
    console.log(choco)
    // Cat {bark: '야옹', name: '초코', age: 7}
    ```
    

## 02. 명시적으로 this를 바인딩하는 방법

여러 상황별로 this에 바인딩되는 예시를 살펴봐지만 규칙을 깨고 별도 대상이 바인딩 될 때도 있음. 

앞에서 설명한 규칙이 맞지 않는다면 다음 방법 중 하나를 사용했을 수도 있다. 

### 1) call 메서드

- 호출주체인 함수를 즉시 실행하도록 함.
- 첫번째 인자를 this로 바인딩
- 이후 인자들은 호출할 함수의 매개변수
- 언제쓰나? 그냥 함수쓰면 this가 전역객체로 되는 것을, call 메서드를 이용하면 임의의 객체를 this로 지정 가능

```jsx
var func = funciton (a,b,c) {
	console.log(this, a,b,c);
}
func(1,2,3) //window{...}1 2 3 
func.call({x: 1},4,5,6,) // {x:1} 4 5  6
```

### 2) apply 메서드

- call 메서드랑 기능 완전 같음
- 다른점 : 두번째 인자를 ‘배열’로 받아 배열요소 호출할 함수의 매개변수로 지정.

### 3) call / apply 메서드의 활용사례

 (1) 유사배열객체에 배열 메서드 적용

- 객체에 배열메서드를 직접적으로 사용 불가능. but 유사배열객체일땐 call 또는 apply 메서드 이용해 배열 메서드 쓸 수 있다.
- ES6에선 유사배열객체 또는 순회 가능 모든 종류의 데이터 타입을 배열로 전환하는 Array.from 메서드 도입.

(2) 생성자 내부에서 다른 생성자 호출

- 생성자 내부에서 다른 생성자와 공통된 내용이 있을 경우,
call 또는 apply를 쓰면 반복을 줄일 수 있다.

(3) 여러 인수 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용

- 여러개 인수 받는 메서드에게 하나의 배열로 인수 전달하고 싶을 때

### 4) bind 메서드

- es5에서 추가된 기능
- call과 비슷 but, 즉시 호출하지는 않고 념겨 받은 this 및 인수들 바탕으로 새로운함수 반환

### 5) 화살표 함수의 예외사항

- 화살표 함수는 함수이긴하지만 , 실행컨텍스트 생성할 때 this 바인딩하는 과정이 제외됨. 
⇒ 함수 내부에는 this가 아예 없고 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 된다.

### 6) 별도의 인자로 this를 받는 경우  ( 콜백 함수 내에서의 this)

- 콜백 함수 내부에서 this값을 원하는 대로 변경할 수 있다. ⇒ 배열메서드, Set, Map 메서드에서 이런 특징이 나온다.

# 정리

다음 규칙은 명시적this바인딩 없는 한 늘 성립.

- 전역공간에서 this는 전역객체 참조 ( 브라우저에서 전역객체: window , node.js에서 전역객체 : global)
- 함수를 메서드로서 호출하면 this는→ 메서드 호출주체(메서드명 앞의 객체) 참조
- 함수를 함수로서 호출하면 this는 → 전역객체 참조. 메서드의 내부함수에서도 함수로 호출하면 전역객체.
- 콜백함수 내부에서 this는 → 콜백함수 제어권 받은 함수가 정의한대로 따른다. 정의안하면 전역객체
- 생성자 함수에서 this 는 → 생성될 인스턴스 참조

명시적 this 바인딩 규칙

- call, apply 메서드: this를 명시적으로 지정하면서 함수 또는 메서드 호출
- bind 메서드 : this 및 함수에 넘길 인수를 일부 지정 ⇒ 새로운 함수로 만듬
- 요소 순회하면서 콜백 함수를 반복 호출하는 일부 메서드 ⇒ 별도의 인자로 this를 받기도 한다.
